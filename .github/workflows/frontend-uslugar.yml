name: Frontend - Build & Deploy (Hostinger)

on:
  workflow_dispatch:  # Manual trigger - uvijek dostupan
  push:
    branches: ["main"]
    paths:
      - "Uslugar/frontend/**"  # Frontend je u Uslugar folderu
      - ".github/workflows/frontend-uslugar.yml"  # Promjene u workflow fajlu

permissions:
  id-token: write
  contents: read

env:
  FRONTEND_DIR: Uslugar/frontend
  BUILD_CMD: npm ci && npm run build
  DIST_DIR: Uslugar/frontend/dist
  # ‚ûú Server directory - will be determined in "Determine SERVER_DIR" step
  # Based on URL pattern (.../files/), default is "public_html/"
  # If you see duplicate public_html/public_html/, set HOSTINGER_SERVER_DIR secret to "/"
  SERVER_DIR: ${{ secrets.HOSTINGER_SERVER_DIR && secrets.HOSTINGER_SERVER_DIR || '' }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Samo ako postoji package.json ‚Äì pripremi lockfile za cache
      - name: Ensure package-lock.json (if Node project)
        run: |
          set -e
          if [ -f "${{ env.FRONTEND_DIR }}/package.json" ]; then
            cd "${{ env.FRONTEND_DIR }}"
            test -f package-lock.json || npm i --package-lock-only
          else
            echo "No package.json -> static site"
          fi

      - name: Setup Node (if Node project)
        if: ${{ hashFiles(format('{0}/package.json', env.FRONTEND_DIR)) != '' }}
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: ${{ env.FRONTEND_DIR }}/package-lock.json

      - name: Detect framework (static aware)
        id: fw
        working-directory: ${{ env.FRONTEND_DIR }}
        shell: bash
        run: |
          set -euo pipefail
          FW=$(node -e '
            let p=null; try { p=require("./package.json"); } catch(e) {}
            if(!p){ process.stdout.write("static"); process.exit(0); }
            const d={...(p.dependencies||{}), ...(p.devDependencies||{})};
            if (d.next) process.stdout.write("next");
            else if (d.vite) process.stdout.write("vite");
            else if (d["react-scripts"]) process.stdout.write("cra");
            else if (d["@angular/cli"]) process.stdout.write("angular");
            else process.stdout.write("unknown");
          ')
          echo "framework=$FW" >> "$GITHUB_OUTPUT"
          echo "Detected: $FW"

      - name: Build (skip for static)
        if: ${{ steps.fw.outputs.framework != 'static' }}
        working-directory: ${{ env.FRONTEND_DIR }}
        env:
          VITE_API_URL: ${{ secrets.VITE_API_URL || 'https://api.uslugar.eu' }}
        shell: bash
        run: |
          set -euo pipefail
          case "${{ steps.fw.outputs.framework }}" in
            next)
              if npm run -s | grep -qE '^ *export *'; then
                npm ci && npm run build && npm run export
              else
                npm ci && npm run build && npx --yes next export || true
              fi
              ;;
            cra)
              npm ci && npm run build
              ;;
            angular|vite|unknown)
              eval "${BUILD_CMD}"
              ;;
          esac

      - name: List artifacts (debug)
        working-directory: ${{ env.FRONTEND_DIR }}
        run: |
          echo "== top =="; ls -la
          echo "== dist =="; ls -la dist || true
          echo "== build =="; ls -la build || true
          echo "== out =="; ls -la out || true
          echo "== .next =="; ls -la .next || true

      - name: Detect output dir
        id: detect
        working-directory: ${{ env.FRONTEND_DIR }}
        shell: bash
        run: |
          set -euo pipefail
          fw="${{ steps.fw.outputs.framework }}"
          candidates=()
          if [ "$fw" = "next" ]; then candidates+=("out" ".next"); fi
          candidates+=("${DIST_DIR}" "dist" "build" "out" "public" ".")  # <-- dodali "."
          echo "Candidates: ${candidates[*]}"
          found=""
          for d in "${candidates[@]}"; do
            if [ -d "$d" ]; then
              if [ -f "$d/index.html" ]; then found="$d"; break; fi
              if [ "$d" != ".next" ] && [ "$(find "$d" -type f | wc -l)" -gt 0 ]; then found="$d"; break; fi
            fi
          done
          if [ -z "$found" ] && [ -d ".next" ]; then
            echo "SSR build (.next) se ne mo≈æe deployati preko FTP-a bez servera."; exit 1
          fi
          if [ -z "$found" ]; then
            echo "Nije naƒëen build output (index.html)."; exit 1
          fi
          echo "dir=$found" >> "$GITHUB_OUTPUT"
          echo "Using: $found"

      - name: Validate FTP Secrets
        run: |
          echo "üîç Validating FTP configuration..."
          
          # Check for HOSTINGER secrets first, then fallback to generic FTP secrets
          if [ -n "${{ secrets.HOSTINGER_HOST }}" ]; then
            FTP_HOST="${{ secrets.HOSTINGER_HOST }}"
            FTP_USER="${{ secrets.HOSTINGER_USERNAME }}"
            FTP_PASS="${{ secrets.HOSTINGER_PASSWORD }}"
            echo "‚úÖ Using HOSTINGER_* secrets"
          elif [ -n "${{ secrets.FTP_HOST }}" ]; then
            FTP_HOST="${{ secrets.FTP_HOST }}"
            FTP_USER="${{ secrets.FTP_USERNAME }}"
            FTP_PASS="${{ secrets.FTP_PASSWORD }}"
            echo "‚úÖ Using FTP_* secrets (fallback)"
          else
            echo "‚ùå ERROR: No FTP secrets found!"
            echo "   Required secrets (one of):"
            echo "   - HOSTINGER_HOST, HOSTINGER_USERNAME, HOSTINGER_PASSWORD"
            echo "   - FTP_HOST, FTP_USERNAME, FTP_PASSWORD"
            echo "   Please add them in: Settings > Secrets and variables > Actions"
            exit 1
          fi
          
          if [ -z "$FTP_HOST" ]; then
            echo "‚ùå ERROR: FTP host is missing!"
            echo "   Please add HOSTINGER_HOST or FTP_HOST secret"
            exit 1
          fi
          if [ -z "$FTP_USER" ]; then
            echo "‚ùå ERROR: FTP username is missing!"
            echo "   Please add HOSTINGER_USERNAME or FTP_USERNAME secret"
            exit 1
          fi
          if [ -z "$FTP_PASS" ]; then
            echo "‚ùå ERROR: FTP password is missing!"
            echo "   Please add HOSTINGER_PASSWORD or FTP_PASSWORD secret"
            exit 1
          fi
          
          # Clean host format (remove protocol prefix if present)
          CLEANED_HOST="$FTP_HOST"
          if [[ "$CLEANED_HOST" == ftp://* ]]; then
            CLEANED_HOST="${CLEANED_HOST#ftp://}"
            echo "‚ö†Ô∏è  Removed ftp:// prefix from host"
          fi
          if [[ "$CLEANED_HOST" == ftps://* ]]; then
            CLEANED_HOST="${CLEANED_HOST#ftps://}"
            echo "‚ö†Ô∏è  Removed ftps:// prefix from host"
          fi
          if [[ "$CLEANED_HOST" == sftp://* ]]; then
            CLEANED_HOST="${CLEANED_HOST#sftp://}"
            echo "‚ö†Ô∏è  Removed sftp:// prefix from host"
          fi
          # Remove trailing slash
          CLEANED_HOST="${CLEANED_HOST%/}"
          # Remove port if included in host
          CLEANED_HOST="${CLEANED_HOST%:*}"
          
          echo "‚úÖ All required secrets are present"
          echo "   Original host: ${FTP_HOST:0:30}..."
          echo "   Cleaned host: $CLEANED_HOST"
          echo "   Username: $FTP_USER"
          echo "   Password: [hidden]"
          echo "   Server dir: ${{ env.SERVER_DIR }}"
          
          # Validate host format
          if [[ "$CLEANED_HOST" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || [[ "$CLEANED_HOST" =~ ^[a-zA-Z0-9.-]+$ ]]; then
            echo "‚úÖ Host format is valid: $CLEANED_HOST"
          else
            echo "‚ö†Ô∏è  WARNING: Host format may be invalid: $CLEANED_HOST"
          fi
          
          # Export cleaned values for use in deployment steps
          echo "FTP_HOST=$CLEANED_HOST" >> $GITHUB_ENV
          echo "FTP_USER=$FTP_USER" >> $GITHUB_ENV
          echo "FTP_PASS=$FTP_PASS" >> $GITHUB_ENV
          
          # Save for troubleshooting
          echo "FTP_HOST_FOR_DEBUG=$CLEANED_HOST" >> $GITHUB_ENV

      - name: Determine SERVER_DIR based on structure
        id: determine-dir
        run: |
          echo "üîç Determining correct SERVER_DIR..."
          echo ""
          # If secret is set, use it
          if [ -n "${{ secrets.HOSTINGER_SERVER_DIR }}" ]; then
            DETERMINED_DIR="${{ secrets.HOSTINGER_SERVER_DIR }}"
            echo "‚úÖ Using HOSTINGER_SERVER_DIR secret: '$DETERMINED_DIR'"
          else
            # Based on URL pattern: .../files/ suggests FTP root is at /files/
            # So we need to add public_html/ to get to .../files/public_html/
            DETERMINED_DIR="public_html/"
            echo "‚ö†Ô∏è  No HOSTINGER_SERVER_DIR secret found"
            echo "üìã Based on your URL pattern (.../files/), using: '$DETERMINED_DIR'"
            echo ""
            echo "‚ÑπÔ∏è  If you see 'public_html/public_html/' in URL:"
            echo "   ‚Üí Your FTP root is already in public_html/"
            echo "   ‚Üí Set HOSTINGER_SERVER_DIR secret to '/'"
            echo ""
            echo "‚ÑπÔ∏è  If files are in root (without public_html/):"
            echo "   ‚Üí Your FTP root is above public_html/"
            echo "   ‚Üí Set HOSTINGER_SERVER_DIR secret to 'public_html/' (current default)"
          fi
          
          # Handle empty string (means use root)
          if [ -z "$DETERMINED_DIR" ] || [ "$DETERMINED_DIR" = "/" ]; then
            DETERMINED_DIR="/"
            echo "üìå Using root directory '/'"
            echo ""
            echo "‚ö†Ô∏è  WARNING: Using root directory '/'"
            echo "   This will upload files to FTP root (wherever you are after login)"
            echo "   Based on your URL pattern (.../files/), this suggests FTP root is at /files/"
            echo "   If you see '.../files/' without public_html/, you need to add public_html/"
            echo ""
            echo "üí° SOLUTION:"
            echo "   ‚Üí Update HOSTINGER_SERVER_DIR secret to 'public_html/'"
            echo "   ‚Üí Or remove the secret to use default 'public_html/'"
          else
            # Ensure trailing slash for non-root directories
            if [[ "$DETERMINED_DIR" != */ ]]; then
              DETERMINED_DIR="${DETERMINED_DIR}/"
            fi
            echo "üìå Using directory: '$DETERMINED_DIR'"
          fi
          
          echo "SERVER_DIR=$DETERMINED_DIR" >> $GITHUB_ENV
          echo "determined_dir=$DETERMINED_DIR" >> $GITHUB_OUTPUT
          echo ""
          echo "‚úÖ Final SERVER_DIR: '$DETERMINED_DIR'"
          echo ""
          echo "üìã Expected result:"
          if [ "$DETERMINED_DIR" = "/" ]; then
            echo "   ‚ùå Files will be uploaded to FTP root"
            echo "   ‚ùå Expected URL: .../files/ (WITHOUT public_html/)"
            echo ""
            echo "   ‚ö†Ô∏è  This is probably WRONG for Hostinger!"
            echo "   ‚Üí Your files should be in public_html/"
            echo "   ‚Üí Update HOSTINGER_SERVER_DIR secret to 'public_html/'"
          else
            echo "   ‚úÖ Files will be uploaded to: $DETERMINED_DIR"
            echo "   ‚úÖ Expected URL: .../files/$DETERMINED_DIR"
            if [ "$DETERMINED_DIR" = "public_html/" ]; then
              echo ""
              echo "   ‚úÖ This is CORRECT for Hostinger structure!"
            fi
          fi

      - name: Test FTP connection
        continue-on-error: true
        run: |
          echo "üîç Testing FTP connection..."
          echo "Host: ${{ env.FTP_HOST }}"
          echo ""
          echo "Testing port 21 (FTP):"
          if timeout 10 bash -c "echo > /dev/tcp/${{ env.FTP_HOST }}/21" 2>/dev/null; then
            echo "‚úÖ Port 21 is reachable"
          else
            echo "‚ùå Port 21 timeout - server may be unreachable or firewall blocked"
            echo "   This could mean:"
            echo "   - Firewall blocks port 21"
            echo "   - Server doesn't support FTP on port 21"
            echo "   - Network connectivity issue"
            echo "   - Host/IP address is incorrect"
          fi
          echo ""
          echo "Testing port 22 (SFTP):"
          if timeout 10 bash -c "echo > /dev/tcp/${{ env.FTP_HOST }}/22" 2>/dev/null; then
            echo "‚úÖ Port 22 (SFTP) is reachable - will try SFTP as fallback"
          else
            echo "‚ö†Ô∏è  Port 22 also not reachable"
          fi
          echo ""
          echo "Testing port 990 (FTPS):"
          if timeout 10 bash -c "echo > /dev/tcp/${{ env.FTP_HOST }}/990" 2>/dev/null; then
            echo "‚úÖ Port 990 (FTPS) is reachable"
          else
            echo "‚ö†Ô∏è  Port 990 not reachable"
          fi
          echo ""
          echo "‚ÑπÔ∏è  Troubleshooting:"
          echo "   1. Verify FTP host: ${{ env.FTP_HOST }}"
          echo "   2. Check GitHub Secrets are set correctly"
          echo "   3. Test connection manually with FileZilla"
          echo "   4. Server may only support SFTP (port 22)"
          echo "   5. Firewall may block port 21"
          echo "   6. Try manual deployment: Uslugar/frontend/deploy-frontend-ftp-fixed.ps1"

      - name: Deploy via FTP (plain FTP - first attempt)
        id: deploy-ftp
        continue-on-error: true
        uses: SamKirkland/FTP-Deploy-Action@v4.3.6
        with:
          server: ${{ env.FTP_HOST }}
          username: ${{ env.FTP_USER }}
          password: ${{ env.FTP_PASS }}
          protocol: 'ftp'
          port: 21
          local-dir: ${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/
          server-dir: ${{ env.SERVER_DIR || steps.determine-dir.outputs.determined_dir }}
          dangerous-clean-slate: false
          timeout: 600000
          log-level: verbose
          state-name: .ftp-deploy-sync-state.json
          dry-run: false
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/.DS_Store

      - name: Retry with FTP (passive mode)
        if: steps.deploy-ftp.outcome == 'failure'
        continue-on-error: true
        uses: SamKirkland/FTP-Deploy-Action@v4.3.6
        with:
          server: ${{ env.FTP_HOST }}
          username: ${{ env.FTP_USER }}
          password: ${{ env.FTP_PASS }}
          protocol: 'ftp'
          port: 21
          local-dir: ${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/
          server-dir: ${{ env.SERVER_DIR || steps.determine-dir.outputs.determined_dir }}
          dangerous-clean-slate: false
          timeout: 600000
          log-level: verbose
          state-name: .ftp-deploy-sync-state.json
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/.DS_Store

      - name: Retry with FTPS (implicit - only if FTP fails)
        if: steps.deploy-ftp.outcome == 'failure'
        continue-on-error: true
        uses: SamKirkland/FTP-Deploy-Action@v4.3.6
        with:
          server: ${{ env.FTP_HOST }}
          username: ${{ env.FTP_USER }}
          password: ${{ env.FTP_PASS }}
          protocol: 'ftps'
          port: 21
          local-dir: ${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/
          server-dir: ${{ env.SERVER_DIR || steps.determine-dir.outputs.determined_dir }}
          dangerous-clean-slate: false
          timeout: 600000
          log-level: verbose
          security: loose
          state-name: .ftp-deploy-sync-state.json
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/.DS_Store

      - name: Final retry with FTPS (explicit - port 990)
        if: steps.deploy-ftp.outcome == 'failure'
        continue-on-error: true
        uses: SamKirkland/FTP-Deploy-Action@v4.3.6
        with:
          server: ${{ env.FTP_HOST }}
          username: ${{ env.FTP_USER }}
          password: ${{ env.FTP_PASS }}
          protocol: 'ftps'
          port: 990
          local-dir: ${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/
          server-dir: ${{ env.SERVER_DIR || steps.determine-dir.outputs.determined_dir }}
          dangerous-clean-slate: false
          timeout: 600000
          log-level: verbose
          security: explicit
          state-name: .ftp-deploy-sync-state.json
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/.DS_Store

      - name: Try SFTP (if FTP/FTPS failed)
        if: steps.deploy-ftp.outcome == 'failure'
        continue-on-error: true
        uses: SamKirkland/FTP-Deploy-Action@v4.3.6
        with:
          server: ${{ env.FTP_HOST }}
          username: ${{ env.FTP_USER }}
          password: ${{ env.FTP_PASS }}
          protocol: 'sftp'
          port: 22
          local-dir: ${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/
          server-dir: ${{ env.SERVER_DIR || steps.determine-dir.outputs.determined_dir }}
          dangerous-clean-slate: false
          timeout: 600000
          log-level: verbose
          state-name: .ftp-deploy-sync-state.json
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
            **/.DS_Store

      - name: Upload .htaccess file
        if: steps.deploy-ftp.outcome == 'success' || steps.deploy-ftp.outcome == 'failure'
        continue-on-error: true
        run: |
          echo "üì§ Uploading .htaccess file..."
          
          # Check multiple locations for .htaccess file (like AWS workflow)
          HTACCESS_FILE=""
          if [ -f "${{ env.FRONTEND_DIR }}/.htaccess" ]; then
            HTACCESS_FILE="${{ env.FRONTEND_DIR }}/.htaccess"
            echo "‚úÖ Found .htaccess at ${{ env.FRONTEND_DIR }}/.htaccess"
          elif [ -f "${{ env.FRONTEND_DIR }}/public/.htaccess" ]; then
            HTACCESS_FILE="${{ env.FRONTEND_DIR }}/public/.htaccess"
            echo "‚úÖ Found .htaccess at ${{ env.FRONTEND_DIR }}/public/.htaccess"
          elif [ -f "${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/.htaccess" ]; then
            HTACCESS_FILE="${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/.htaccess"
            echo "‚úÖ Found .htaccess at ${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/.htaccess"
          fi
          
          if [ -n "$HTACCESS_FILE" ]; then
            SERVER_DIR_VALUE="${{ env.SERVER_DIR || steps.determine-dir.outputs.determined_dir }}"
            echo "üì§ Uploading $HTACCESS_FILE to ${SERVER_DIR_VALUE}.htaccess"
            
            # Use curl to upload via FTP (try plain FTP first, then FTPS)
            curl -T "$HTACCESS_FILE" \
              --user "${{ env.FTP_USER }}:${{ env.FTP_PASS }}" \
              "ftp://${{ env.FTP_HOST }}/${SERVER_DIR_VALUE}.htaccess" \
              || curl -T "$HTACCESS_FILE" \
                --ftp-ssl \
                --user "${{ env.FTP_USER }}:${{ env.FTP_PASS }}" \
                "ftps://${{ env.FTP_HOST }}/${SERVER_DIR_VALUE}.htaccess"
            
            echo "‚úÖ .htaccess uploaded successfully"
          else
            echo "‚ö†Ô∏è  .htaccess file not found in any expected location:"
            echo "   - ${{ env.FRONTEND_DIR }}/.htaccess"
            echo "   - ${{ env.FRONTEND_DIR }}/public/.htaccess"
            echo "   - ${{ env.FRONTEND_DIR }}/${{ steps.detect.outputs.dir }}/.htaccess"
            echo "   Skipping .htaccess upload"
          fi

      - name: Check deployment result
        id: check-deploy
        run: |
          if [ "${{ steps.deploy-ftp.outcome }}" == "success" ]; then
            echo "‚úÖ Deployment successful!"
            echo "result=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå All deployment attempts failed"
            echo "result=failure" >> $GITHUB_OUTPUT
          fi

      - name: Deployment failed - Detailed troubleshooting
        if: steps.check-deploy.outputs.result == 'failure'
        run: |
          echo "‚ùå FTP/SFTP Deployment failed after all retry attempts"
          echo ""
          echo "üìã Configuration used:"
          echo "   Host: ${{ env.FTP_HOST_FOR_DEBUG }}"
          echo "   Username: ${{ env.FTP_USER }}"
          echo "   Server dir: ${{ env.SERVER_DIR }}"
          echo ""
          echo "üîç Attempted protocols:"
          echo "   ‚ùå FTP (port 21) - plain"
          echo "   ‚ùå FTP (port 21) - passive mode"
          echo "   ‚ùå FTPS (port 21) - implicit"
          echo "   ‚ùå FTPS (port 990) - explicit"
          echo "   ‚ùå SFTP (port 22) - if attempted"
          echo ""
          echo "üîç Troubleshooting steps:"
          echo ""
          echo "1. ‚úÖ Verify GitHub Secrets (Settings > Secrets and variables > Actions):"
          echo "   - HOSTINGER_HOST or FTP_HOST = hostname only (no ftp://, no port)"
          echo "     Example: ftp.uslugar.eu or 194.5.156.10"
          echo "   - HOSTINGER_USERNAME or FTP_USERNAME = your FTP username"
          echo "   - HOSTINGER_PASSWORD or FTP_PASSWORD = your FTP password"
          echo "   - HOSTINGER_SERVER_DIR = / (optional, defaults to / - FTP root is already in public_html/)"
          echo "     If you see 'public_html/public_html/' in URL, remove this secret or set it to '/'"
          echo ""
          echo "2. üîç Test connection manually with FileZilla:"
          echo "   - Host: ${{ env.FTP_HOST_FOR_DEBUG }}"
          echo "   - Port: 21 (for FTP) or 22 (for SFTP)"
          echo "   - Username: ${{ env.FTP_USER }}"
          echo "   - Password: [check your secret]"
          echo "   - Protocol: FTP or SFTP (try both)"
          echo ""
          echo "3. üîç Test connection with PowerShell (if available locally):"
          echo "   cd Uslugar/frontend"
          echo "   .\deploy-frontend-ftp-fixed.ps1"
          echo ""
          echo "4. ‚öôÔ∏è  Check Hostinger Control Panel:"
          echo "   - Verify FTP account is enabled"
          echo "   - Check if FTP credentials are correct"
          echo "   - Verify server supports FTP (not just SFTP)"
          echo "   - Check firewall settings"
          echo ""
          echo "5. üîß Common fixes:"
          echo "   - Remove 'ftp://' or 'ftps://' prefix from host secret"
          echo "   - Remove port number from host (use default 21 for FTP, 22 for SFTP)"
          echo "   - Try using IP address instead of hostname"
          echo "   - Verify credentials in Hostinger control panel"
          echo "   - Check if server requires passive mode (already tried)"
          echo ""
          echo "6. üìÅ Alternative deployment methods:"
          echo "   üìÅ Manual FTP: Use FileZilla to upload Uslugar/frontend/dist/* to public_html/"
          echo "   üìÅ Manual Script: Run Uslugar/frontend/deploy-frontend-ftp-fixed.ps1 locally"
          echo "   üìÅ Hostinger File Manager: Upload files via web interface"
          echo "   üìÅ SSH/SCP: If SSH is available, use scp or rsync"
          echo ""
          echo "7. üí° If server only supports SFTP:"
          echo "   - SFTP was attempted automatically (port 22)"
          echo "   - If SFTP also failed, verify SFTP credentials"
          echo "   - Contact Hostinger support to enable FTP/FTPS if needed"
          echo ""
          echo "8. üîç Check workflow logs above for specific error messages:"
          echo "   - Look for connection timeout errors"
          echo "   - Look for authentication errors"
          echo "   - Look for protocol mismatch errors"
          echo ""
          echo "‚ùå Deployment failed. Please review the troubleshooting steps above."
          exit 1

